# QA Automation Agent - FINAL IMPLEMENTATION PLAN

> Desktop-level QA automation using **Daytona + browser-use** to visually test applications

**Built for Daytona Hacksprint 2025**

---

## ğŸ“‹ Executive Summary

**What We're Building:**
- AI-powered QA automation that tests web apps like a human tester
- Spins up app in Daytona workspace, runs browser-use agent to test it
- Returns step-by-step screenshots + full video recording + pass/fail results

**Key Technology Decisions:**
- âœ… **Backend**: Bun + Elysia (TypeScript) - *keep existing architecture*
- âœ… **Testing Engine**: browser-use (Python) - *called via scripts*
- âœ… **Browser**: Open source browser-use (not cloud) - *runs in workspace*
- âœ… **Recording**: Screenshots per step + full video - *both automatically captured*
- âœ… **Deployment**: Everything in one Daytona workspace - *self-contained*

---

## ğŸ—ï¸ Architecture Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  EXTERNAL API (Bun/TypeScript)                          â”‚
â”‚  - Elysia REST API                                       â”‚
â”‚  - PostgreSQL + Drizzle ORM                              â”‚
â”‚  - Inngest background jobs                               â”‚
â”‚  - Triggers QA runs via Daytona SDK                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  DAYTONA WORKSPACE (All-in-One)                         â”‚
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  APP UNDER TEST (Next.js/React/etc)                â”‚ â”‚
â”‚  â”‚  â†’ Cloned from GitHub                              â”‚ â”‚
â”‚  â”‚  â†’ npm install && npm run dev                      â”‚ â”‚
â”‚  â”‚  â†’ Running on localhost:3000                       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  BROWSER-USE TESTING (Python)                      â”‚ â”‚
â”‚  â”‚                                                     â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚  â”‚  â”‚ Python Script (generated by backend)         â”‚ â”‚ â”‚
â”‚  â”‚  â”‚ - browser-use agent                          â”‚ â”‚ â”‚
â”‚  â”‚  â”‚ - Chromium (headless)                        â”‚ â”‚ â”‚
â”‚  â”‚  â”‚ - Tests localhost:3000                       â”‚ â”‚ â”‚
â”‚  â”‚  â”‚ - Auto screenshots + video                   â”‚ â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                          â”‚
â”‚  Results â†’ JSON output â†’ Backend parses â†’ Save to DB    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  FRONTEND (Next.js 15)                                  â”‚
â”‚  - Timeline with step-by-step screenshots               â”‚
â”‚  - Video player for full session                        â”‚
â”‚  - Pass/fail statistics                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“Š Tech Stack

### Backend (api/)
| Component | Technology | Purpose |
|-----------|-----------|---------|
| Runtime | **Bun** | Fast TypeScript execution |
| Framework | **Elysia** | Lightweight REST API |
| Database | **PostgreSQL + Drizzle ORM** | Persistent storage |
| Jobs | **Inngest** | Durable background execution |
| Workspace Control | **Daytona SDK** | Create/manage workspaces |

### Testing Engine (runs in workspace)
| Component | Technology | Purpose |
|-----------|-----------|---------|
| Agent | **browser-use (Python)** | AI browser automation |
| LLM | **ChatBrowserUse** | Optimized for browser tasks |
| Browser | **Chromium (headless)** | Runs tests |

### Frontend (web/)
| Component | Technology | Purpose |
|-----------|-----------|---------|
| Framework | **Next.js 15** | React UI |
| State | **TanStack Query** | API data fetching |
| UI | **Radix UI + Tailwind + shadcn/ui** | Components |

---

## ğŸ“ File Structure

```
daytona-hackathon/
â”œâ”€â”€ api/                          # Backend (Bun/TypeScript)
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ lib/                  # Client initialization
â”‚   â”‚   â”‚   â”œâ”€â”€ daytona.ts        # Daytona SDK client
â”‚   â”‚   â”‚   â”œâ”€â”€ client.ts         # Database client
â”‚   â”‚   â”‚   â”œâ”€â”€ inngest-client.ts # Inngest client
â”‚   â”‚   â”‚   â””â”€â”€ env.ts            # Environment variables
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ db/                   # Database schemas
â”‚   â”‚   â”‚   â”œâ”€â”€ qaRun.db.ts       # QA run entity
â”‚   â”‚   â”‚   â”œâ”€â”€ testFlow.db.ts    # Test flow entity
â”‚   â”‚   â”‚   â””â”€â”€ testStep.db.ts    # Test step entity
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ service/              # Business logic
â”‚   â”‚   â”‚   â”œâ”€â”€ qaRun/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ QaRun.service.ts      # API routes + logic
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ QaRun.jobs.ts         # Inngest jobs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ QaRun.python.ts       # Python script generator
â”‚   â”‚   â”‚   â”œâ”€â”€ testFlow/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ TestFlow.service.ts   # Test flow CRUD
â”‚   â”‚   â”‚   â””â”€â”€ workspace/
â”‚   â”‚   â”‚       â””â”€â”€ Workspace.service.ts  # Daytona operations
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ index.ts              # API entry point
â”‚   â”‚
â”‚   â”œâ”€â”€ drizzle.config.ts
â”‚   â””â”€â”€ package.json
â”‚
â”œâ”€â”€ web/                          # Frontend (Next.js)
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”‚   â”œâ”€â”€ page.tsx          # Home page (create QA run)
â”‚   â”‚   â”‚   â””â”€â”€ qa-runs/
â”‚   â”‚   â”‚       â””â”€â”€ [id]/
â”‚   â”‚   â”‚           â””â”€â”€ page.tsx  # QA run detail + timeline
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ components/
â”‚   â”‚       â”œâ”€â”€ QaRunForm.tsx     # Create QA run form
â”‚   â”‚       â”œâ”€â”€ QaRunTimeline.tsx # Step-by-step results
â”‚   â”‚       â””â”€â”€ VideoPlayer.tsx   # Full session video
â”‚   â”‚
â”‚   â””â”€â”€ package.json
â”‚
â””â”€â”€ README.md
```

---

## ğŸ—„ï¸ Database Schema

### QA Runs Table

```typescript
// api/src/db/qaRun.db.ts

export interface QaRunEntity {
  id: Id<'qaRun'>;
  createdAt: string;
  updatedAt: string;

  // App under test
  repoUrl: string;
  appName: string;
  branch: string;

  // Daytona workspace
  daytonaWorkspaceId: string;
  appLocalUrl: string;                // http://localhost:3000

  // Test execution
  testFlowIds: Id<'testFlow'>[];
  status: 'pending' | 'setting_up' | 'running_tests' | 'completed' | 'failed';

  // Results
  totalSteps: number;
  passedSteps: number;
  failedSteps: number;

  // Recording (from browser-use)
  videoRecordingUrl: string | null;   // Full session video
  videoRecordingPath: string | null;  // Path in workspace

  // Error tracking
  errorMessage: string | null;

  // Timestamps
  startedAt: string | null;
  completedAt: string | null;
}

export const qaRunsTable = pgTable('qa_runs', {
  id: text('id').$type<Id<'qaRun'>>().primaryKey(),
  createdAt: text('created_at').notNull(),
  updatedAt: text('updated_at').notNull(),
  repoUrl: text('repo_url').notNull(),
  appName: text('app_name').notNull(),
  branch: text('branch').default('main'),
  daytonaWorkspaceId: text('daytona_workspace_id').notNull(),
  appLocalUrl: text('app_local_url').default('http://localhost:3000'),
  testFlowIds: jsonb('test_flow_ids').$type<Id<'testFlow'>[]>().notNull(),
  status: text('status').notNull(),
  totalSteps: integer('total_steps').default(0),
  passedSteps: integer('passed_steps').default(0),
  failedSteps: integer('failed_steps').default(0),
  videoRecordingUrl: text('video_recording_url'),
  videoRecordingPath: text('video_recording_path'),
  errorMessage: text('error_message'),
  startedAt: text('started_at'),
  completedAt: text('completed_at'),
});
```

### Test Flows Table

```typescript
// api/src/db/testFlow.db.ts

export interface TestFlowEntity {
  id: Id<'testFlow'>;
  createdAt: string;
  name: string;
  description: string;

  // Natural language task for browser-use agent
  task: string;  // e.g., "Go to localhost:3000, login with test@example.com, verify dashboard"

  // Is this a pre-built demo flow?
  isDemo: boolean;
}

export const testFlowsTable = pgTable('test_flows', {
  id: text('id').$type<Id<'testFlow'>>().primaryKey(),
  createdAt: text('created_at').notNull(),
  name: text('name').notNull(),
  description: text('description').notNull(),
  task: text('task').notNull(),
  isDemo: integer('is_demo', { mode: 'boolean' }).default(false),
});
```

### Test Steps Table

```typescript
// api/src/db/testStep.db.ts

export interface TestStepEntity {
  id: Id<'testStep'>;
  createdAt: string;

  // Relations
  qaRunId: Id<'qaRun'>;
  testFlowId: Id<'testFlow'>;

  // Step details
  stepNumber: number;
  actionName: string;      // e.g., "click", "input", "navigate"
  description: string;

  // Execution
  status: 'pending' | 'running' | 'passed' | 'failed';
  executedAt: string | null;

  // Visual capture (from browser-use)
  screenshotBase64: string | null;    // Screenshot after this action

  // Error tracking
  errorMessage: string | null;
}

export const testStepsTable = pgTable('test_steps', {
  id: text('id').$type<Id<'testStep'>>().primaryKey(),
  createdAt: text('created_at').notNull(),
  qaRunId: text('qa_run_id').references(() => qaRunsTable.id),
  testFlowId: text('test_flow_id').references(() => testFlowsTable.id),
  stepNumber: integer('step_number').notNull(),
  actionName: text('action_name').notNull(),
  description: text('description').notNull(),
  status: text('status').notNull(),
  executedAt: text('executed_at'),
  screenshotBase64: text('screenshot_base64'),
  errorMessage: text('error_message'),
});
```

---

## ğŸ”„ Complete Workflow

### Phase 1: Create QA Run

```typescript
// Frontend â†’ POST /api/qa-run
{
  "appName": "My E-commerce App",
  "repoUrl": "https://github.com/user/ecommerce",
  "branch": "main",
  "testFlowIds": ["testFlow_login", "testFlow_checkout"]
}

// Backend creates QA run entity
// Triggers Inngest job
```

### Phase 2: Setup Workspace (Inngest Job)

```typescript
// api/src/service/qaRun/QaRun.jobs.ts

export const runQaTestsJob = inngestClient.createFunction(
  { id: 'run-qa-tests' },
  { event: 'qa/run' },
  async ({ event, step }) => {
    const { qaRun, testFlows } = event.data;

    // Step 1: Create Daytona workspace
    const workspace = await step.run('create-workspace', async () => {
      return await WorkspaceService.createWorkspace({
        language: 'typescript',
        public: false,
      });
    });

    // Step 2: Setup app
    await step.run('setup-app', async () => {
      return await WorkspaceService.setupApp(
        workspace.id,
        qaRun.repoUrl,
        qaRun.branch
      );
    });

    // Step 3: Install browser-use
    await step.run('install-browser-use', async () => {
      return await WorkspaceService.installBrowserUse(workspace.id);
    });

    // Step 4: Run each test flow
    for (const testFlow of testFlows) {
      await step.run(`run-flow-${testFlow.id}`, async () => {
        return await QaRunService.executeTestFlow(
          qaRun.id,
          testFlow,
          workspace.id
        );
      });
    }

    // Step 5: Finalize results
    await step.run('finalize', async () => {
      return await QaRunService.finalizeResults(qaRun.id);
    });
  }
);
```

### Phase 3: Execute Test Flow

```typescript
// api/src/service/qaRun/QaRun.service.ts

export abstract class QaRunService {
  /**
   * Execute a test flow using browser-use
   */
  static async executeTestFlow(
    qaRunId: Id<'qaRun'>,
    testFlow: TestFlowEntity,
    workspaceId: string
  ) {
    const workspace = await daytona.get(workspaceId);

    // 1. Generate Python script
    const pythonScript = QaRunPython.generateTestScript(testFlow);

    // 2. Write to workspace
    const scriptPath = `/tmp/test_${testFlow.id}.py`;
    await workspace.writeFile(scriptPath, pythonScript);

    // 3. Execute Python script
    const output = await workspace.process.executeCommand(
      `cd /tmp && python3 test_${testFlow.id}.py`
    );

    // 4. Parse results
    const results = JSON.parse(output);

    // 5. Save steps to database
    await this.saveTestResults(qaRunId, testFlow.id, results);

    // 6. Save video recording
    if (results.video_path) {
      const videoUrl = await this.uploadVideo(
        workspace.id,
        results.video_path
      );
      await db.update(qaRunsTable)
        .set({ videoRecordingUrl: videoUrl })
        .where(eq(qaRunsTable.id, qaRunId));
    }

    return results;
  }

  /**
   * Save test results to database
   */
  static async saveTestResults(
    qaRunId: Id<'qaRun'>,
    testFlowId: Id<'testFlow'>,
    results: any
  ) {
    const screenshots = results.screenshots || [];
    const actions = results.actions || [];

    for (let i = 0; i < actions.length; i++) {
      const step: TestStepEntity = {
        id: generateId('testStep'),
        createdAt: new Date().toISOString(),
        qaRunId,
        testFlowId,
        stepNumber: i + 1,
        actionName: actions[i],
        description: `Step ${i + 1}: ${actions[i]}`,
        status: 'passed',  // browser-use completed it
        executedAt: new Date().toISOString(),
        screenshotBase64: screenshots[i] || null,
        errorMessage: null,
      };

      await db.insert(testStepsTable).values(step);
    }

    // Update QA run stats
    await db.update(qaRunsTable)
      .set({
        totalSteps: actions.length,
        passedSteps: results.success ? actions.length : 0,
        failedSteps: results.success ? 0 : actions.length,
      })
      .where(eq(qaRunsTable.id, qaRunId));
  }
}
```

### Phase 4: Python Script Generation

```typescript
// api/src/service/qaRun/QaRun.python.ts

export abstract class QaRunPython {
  /**
   * Generate Python script for browser-use test
   */
  static generateTestScript(testFlow: TestFlowEntity): string {
    return `
import asyncio
import json
from browser_use import Agent, Browser, ChatBrowserUse

async def run_test():
    # Create browser with video recording
    browser = Browser(
        headless=True,
        record_video_dir="/tmp/recordings",
        window_size={"width": 1920, "height": 1080}
    )

    # Create agent with test task
    agent = Agent(
        task="""${testFlow.task}""",
        browser=browser,
        llm=ChatBrowserUse()
    )

    # Run the test
    history = await agent.run()

    # Collect results
    results = {
        "success": history.is_successful(),
        "screenshots": history.screenshots(),
        "actions": history.action_names(),
        "extracted_content": history.final_result(),
        "errors": [str(e) for e in history.errors() if e is not None],
        "video_path": "/tmp/recordings/video.mp4"
    }

    return results

# Run and output JSON
result = asyncio.run(run_test())
print(json.dumps(result))
`;
  }
}
```

### Phase 5: Workspace Service

```typescript
// api/src/service/workspace/Workspace.service.ts

export abstract class WorkspaceService {
  /**
   * Create Daytona workspace
   */
  static async createWorkspace(options: { language: string; public: boolean }) {
    const workspace = await daytona.create({
      language: options.language,
      public: options.public,
    });

    return { id: workspace.id, workspace };
  }

  /**
   * Clone repo and start dev server
   */
  static async setupApp(
    workspaceId: string,
    repoUrl: string,
    branch: string = 'main'
  ) {
    const workspace = await daytona.get(workspaceId);
    const workDir = '/workspace/app';

    // Clone repository
    await workspace.git.clone(repoUrl, workDir, { branch });

    // Install dependencies
    await workspace.process.executeCommand('npm install', workDir);

    // Install PM2
    await workspace.process.executeCommand('npm install -g pm2');

    // Start dev server
    await workspace.process.executeCommand(
      'pm2 start npm --name "app" -- run dev',
      workDir
    );

    // Wait for server to be ready
    await new Promise(resolve => setTimeout(resolve, 10000));

    return { appUrl: 'http://localhost:3000', ready: true };
  }

  /**
   * Install browser-use in workspace
   */
  static async installBrowserUse(workspaceId: string) {
    const workspace = await daytona.get(workspaceId);

    // Install Python dependencies
    await workspace.process.executeCommand(
      'pip install browser-use && uvx browser-use install'
    );

    return { installed: true };
  }
}
```

---

## ğŸ¨ Frontend Implementation

### QA Run Form

```typescript
// web/src/components/QaRunForm.tsx

'use client';

import { useState } from 'react';
import { useMutation, useQuery } from '@tanstack/react-query';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Checkbox } from '@/components/ui/checkbox';

export function QaRunForm() {
  const [repoUrl, setRepoUrl] = useState('');
  const [appName, setAppName] = useState('');
  const [branch, setBranch] = useState('main');
  const [selectedFlows, setSelectedFlows] = useState<string[]>([]);

  // Fetch test flows
  const { data: testFlows } = useQuery({
    queryKey: ['test-flows'],
    queryFn: () => fetch('/api/test-flow').then(r => r.json()),
  });

  // Create QA run
  const createRun = useMutation({
    mutationFn: (data: any) =>
      fetch('/api/qa-run', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      }).then(r => r.json()),
    onSuccess: (data) => {
      window.location.href = `/qa-runs/${data.id}`;
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    createRun.mutate({
      repoUrl,
      appName,
      branch,
      testFlowIds: selectedFlows,
    });
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-6 max-w-2xl">
      <Input
        placeholder="App Name"
        value={appName}
        onChange={(e) => setAppName(e.target.value)}
        required
      />

      <Input
        placeholder="GitHub Repository URL"
        value={repoUrl}
        onChange={(e) => setRepoUrl(e.target.value)}
        required
      />

      <Input
        placeholder="Branch (default: main)"
        value={branch}
        onChange={(e) => setBranch(e.target.value)}
      />

      <div className="space-y-2">
        <h3 className="font-semibold">Select Test Flows</h3>
        {testFlows?.map(flow => (
          <div key={flow.id} className="flex items-center space-x-2">
            <Checkbox
              id={flow.id}
              checked={selectedFlows.includes(flow.id)}
              onCheckedChange={(checked) => {
                if (checked) {
                  setSelectedFlows([...selectedFlows, flow.id]);
                } else {
                  setSelectedFlows(selectedFlows.filter(id => id !== flow.id));
                }
              }}
            />
            <label htmlFor={flow.id} className="cursor-pointer">
              {flow.name} - {flow.description}
            </label>
          </div>
        ))}
      </div>

      <Button
        type="submit"
        disabled={createRun.isPending || selectedFlows.length === 0}
        className="w-full"
      >
        {createRun.isPending ? 'Starting QA Run...' : 'Run QA Tests'}
      </Button>
    </form>
  );
}
```

### QA Run Timeline

```typescript
// web/src/app/qa-runs/[id]/page.tsx

'use client';

import { useQuery } from '@tanstack/react-query';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { CheckCircle2, XCircle } from 'lucide-react';

export default function QaRunPage({ params }: { params: { id: string } }) {
  // Poll for updates
  const { data: qaRun } = useQuery({
    queryKey: ['qa-run', params.id],
    queryFn: () => fetch(`/api/qa-run/${params.id}`).then(r => r.json()),
    refetchInterval: 3000,
  });

  const { data: steps } = useQuery({
    queryKey: ['qa-run-steps', params.id],
    queryFn: () => fetch(`/api/qa-run/${params.id}/steps`).then(r => r.json()),
    refetchInterval: 3000,
  });

  if (!qaRun) return <div>Loading...</div>;

  return (
    <div className="container mx-auto py-8 space-y-8">
      {/* Header */}
      <div className="flex items-start justify-between">
        <div>
          <h1 className="text-4xl font-bold">{qaRun.appName}</h1>
          <p className="text-muted-foreground">{qaRun.repoUrl}</p>
        </div>
        <Badge>{qaRun.status}</Badge>
      </div>

      {/* Stats */}
      <div className="grid grid-cols-3 gap-4">
        <Card>
          <CardHeader>
            <CardTitle className="text-sm">Total Steps</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-3xl font-bold">{qaRun.totalSteps}</div>
          </CardContent>
        </Card>

        <Card className="border-green-500">
          <CardHeader>
            <CardTitle className="text-sm text-green-700">Passed</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-3xl font-bold text-green-700">
              {qaRun.passedSteps}
            </div>
          </CardContent>
        </Card>

        <Card className="border-red-500">
          <CardHeader>
            <CardTitle className="text-sm text-red-700">Failed</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-3xl font-bold text-red-700">
              {qaRun.failedSteps}
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Video Recording */}
      {qaRun.videoRecordingUrl && (
        <Card>
          <CardHeader>
            <CardTitle>Full Session Recording</CardTitle>
          </CardHeader>
          <CardContent>
            <video
              src={qaRun.videoRecordingUrl}
              controls
              className="w-full rounded-lg"
            />
          </CardContent>
        </Card>
      )}

      {/* Timeline */}
      <div>
        <h2 className="text-2xl font-bold mb-4">Test Timeline</h2>
        <div className="space-y-4">
          {steps?.map(step => (
            <Card
              key={step.id}
              className={
                step.status === 'passed'
                  ? 'border-green-500'
                  : step.status === 'failed'
                  ? 'border-red-500'
                  : ''
              }
            >
              <CardHeader>
                <div className="flex items-center gap-3">
                  {step.status === 'passed' && (
                    <CheckCircle2 className="w-5 h-5 text-green-500" />
                  )}
                  {step.status === 'failed' && (
                    <XCircle className="w-5 h-5 text-red-500" />
                  )}
                  <div>
                    <h3 className="text-lg font-semibold">
                      Step {step.stepNumber}: {step.description}
                    </h3>
                    <p className="text-sm text-muted-foreground">
                      {step.actionName}
                    </p>
                  </div>
                </div>
              </CardHeader>

              {step.screenshotBase64 && (
                <CardContent>
                  <img
                    src={`data:image/png;base64,${step.screenshotBase64}`}
                    alt={`Screenshot for step ${step.stepNumber}`}
                    className="w-full rounded-lg border cursor-pointer"
                    onClick={() => window.open(`data:image/png;base64,${step.screenshotBase64}`)}
                  />
                </CardContent>
              )}
            </Card>
          ))}
        </div>
      </div>
    </div>
  );
}
```

---

## ğŸ¯ Example Test Flows (Seed Data)

```typescript
// api/src/db/seed.ts

export async function seedTestFlows() {
  const flows: TestFlowEntity[] = [
    {
      id: generateId('testFlow'),
      createdAt: new Date().toISOString(),
      name: 'Login Flow',
      description: 'Test user login functionality',
      isDemo: true,
      task: `
Go to http://localhost:3000/login
Find the email input field and enter "test@example.com"
Find the password input field and enter "password123"
Click the login or submit button
Wait for the page to load
Verify that you are now on a dashboard or home page (not the login page)
Extract any welcome message or user information visible on the page
      `.trim(),
    },
    {
      id: generateId('testFlow'),
      createdAt: new Date().toISOString(),
      name: 'Navigation Flow',
      description: 'Test main navigation links',
      isDemo: true,
      task: `
Go to http://localhost:3000
Click on the "Products" navigation link
Wait for the products page to load
Verify that product listings are visible
Click on the "About" navigation link
Wait for the about page to load
Verify that about content is visible
Extract the page title and main heading
      `.trim(),
    },
    {
      id: generateId('testFlow'),
      createdAt: new Date().toISOString(),
      name: 'Form Submission Flow',
      description: 'Test contact form submission',
      isDemo: true,
      task: `
Go to http://localhost:3000/contact
Find and fill in the name field with "John Doe"
Find and fill in the email field with "john@example.com"
Find and fill in the message textarea with "This is a test message"
Click the submit button
Wait for form submission
Verify that a success message appears
Extract the success message text
      `.trim(),
    },
  ];

  for (const flow of flows) {
    await db.insert(testFlowsTable).values(flow);
  }

  console.log(`Seeded ${flows.length} test flows`);
}
```

---

## ğŸš€ Implementation Steps

### Step 1: Database Setup
```bash
cd api
bun install
bun run db:push
bun run db:seed
```

### Step 2: Backend Development
1. âœ… Create database schemas (`qaRun.db.ts`, `testFlow.db.ts`, `testStep.db.ts`)
2. âœ… Implement `WorkspaceService` (Daytona operations)
3. âœ… Implement `QaRunPython` (Python script generator)
4. âœ… Implement `QaRunService` (test execution)
5. âœ… Implement `QaRun.jobs.ts` (Inngest workflow)
6. âœ… Create API routes (Elysia)

### Step 3: Frontend Development
1. âœ… Create `QaRunForm` component
2. âœ… Create `QaRunTimeline` component
3. âœ… Create pages (`/`, `/qa-runs/[id]`)
4. âœ… Setup React Query

### Step 4: Testing
1. Create test Daytona workspace
2. Clone sample Next.js app
3. Run QA flow
4. Verify screenshots + video
5. Debug any issues

---

## ğŸ”‘ Environment Variables

```bash
# api/.env
DATABASE_URL=postgres://...
DAYTONA_API_KEY=...
DAYTONA_API_URL=https://api.daytona.io
INNGEST_EVENT_KEY=...
INNGEST_SIGNING_KEY=...

# For browser-use (set in Daytona workspace)
BROWSER_USE_API_KEY=...
```

---

## âœ… Key Innovations

1. **Hybrid Architecture** - TypeScript backend + Python scripts for testing
2. **All-in-One Workspace** - App + tests in same Daytona workspace
3. **AI-Powered Testing** - browser-use agent understands pages automatically
4. **Visual Timeline** - Screenshots per step + full video recording
5. **Durable Execution** - Inngest handles long-running jobs
6. **Simple Integration** - Just run Python scripts from TypeScript

---

## ğŸ¯ Why This Architecture Works

### Learned from Current Repo:
1. **Service-oriented architecture** - Clean separation of concerns
2. **Inngest for jobs** - Durable execution with steps
3. **Database tracking** - Full audit trail
4. **React Query** - Real-time updates
5. **Daytona integration** - Proven sandbox management

### Applied to QA Agent:
1. **browser-use integration** - AI-powered browser automation
2. **Hybrid approach** - Keep TypeScript backend, use Python for testing
3. **All-in-one workspace** - App + tests together
4. **Timeline UI** - Clear pass/fail visualization with screenshots + video
5. **Natural language test flows** - Simple task descriptions instead of code

---

**Built for Daytona Hacksprint 2025** | Powered by **browser-use + Daytona SDK**
